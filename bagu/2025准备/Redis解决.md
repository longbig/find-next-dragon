# Redis解决

## 1.Redis集群有哪几种模式？

### 一、主从复制模式（Master-Slave）

**核心原理**

- **角色划分**：1个主节点（Master）负责写，多个从节点（Slave）负责读，数据单向同步（Master → Slave）。
- **同步机制**：首次全量同步（RDB快照 + 缓冲区命令），后续增量同步（基于命令传播）。
- **优点**：
  - 读写分离，提升读并发能力。
  - 数据冗余备份，提高可靠性。
- **缺点**：
  - 主节点单点故障需手动切换从节点。
  - 写能力受限于单节点性能，无法横向扩展。

**适用场景**：中小规模读多写少场景，如缓存数据备份。

------

### 二、哨兵模式（Sentinel）

**核心原理**

- **哨兵节点**：独立进程，监控主从节点健康状态，自动触发故障转移（Master宕机时选举新Master）。 

  5

  

- **高可用流程**：

  - 哨兵通过心跳检测判定主节点失效。
  - 半数以上哨兵确认故障后，触发选举新主节点并更新拓扑。

- **优点**：

  - 实现自动故障转移，提升系统可用性。
  - 兼容主从模式，无缝升级。

- **缺点**：

  - 仍无法解决写性能瓶颈和存储容量限制。
  - 数据分片需额外处理（如客户端分片）。

**适用场景**：对高可用要求较高但数据量中等的业务，如核心服务缓存。

------

### 三、Cluster模式（官方分布式方案）

**核心原理**

- **数据分片**：将数据划分为16384个槽（Slot），每个节点管理部分槽，通过CRC16(key) % 16384计算槽位。
- **去中心化架构**：节点间通过Gossip协议通信，客户端直连任意节点，自动重定向请求（MOVED/ASK响应）。
- **高可用机制**：每个主节点可挂载多个从节点，主节点故障时从节点自动晋升。
- **优点**：
  - 支持横向扩展，突破单机内存和性能限制。
  - 自动故障转移和数据迁移，运维成本低。
- **缺点**：
  - 批量操作（如MSET）需保证Key在同一槽。
  - 事务仅支持同一节点内的Key。

**适用场景**：海量数据、高并发场景，如电商订单系统或物流轨迹存储。

------

### 四、第三方方案：Codis（Proxy分片）

**核心原理**

- **代理层**：Codis-Proxy接收客户端请求，根据预定义规则（如CRC32 % 1024）路由到后端Redis实例组（Codis-Group）。
- **依赖组件**：Zookeeper存储集群元数据（如槽位映射）。
- **优点**：
  - 客户端无需感知分片逻辑，兼容Redis协议。
  - 支持平滑扩容和在线迁移。
- **缺点**：
  - 引入代理层增加网络开销和延迟。
  - 已停止维护，官方推荐迁移至Redis Cluster。

**适用场景**：历史遗留项目过渡期使用，新项目不建议采用。

------

### **对比总结**

| **模式**    | **数据分片** | **高可用** | **扩展性** | **运维复杂度** | **适用规模**       |
| :---------- | :----------- | :--------- | :--------- | :------------- | :----------------- |
| 主从复制    | 无           | 低（手动） | 差         | 低             | 小规模备份场景     |
| 哨兵模式    | 无           | 高（自动） | 差         | 中             | 中等规模高可用场景 |
| Cluster模式 | 有（槽分片） | 高         | 优         | 中             | 大规模分布式场景   |
| Codis       | 有（Proxy）  | 中         | 优         | 高             | 旧系统过渡方案     |

**选择建议**：优先使用Redis Cluster满足分布式需求，历史项目可评估Codis迁移成本，哨兵模式适用于无需分片的高可用场景。