# 复盘问题总结

## 1.什么是协程，简单说说

协程是一种轻量级的线程，允许执行中暂停并在之后恢复，不会阻塞线程。协程是在**用户态调度**的，不涉及操作系统内核调度

特点：

* **轻量级**：协程只在用户态切换，避免了线程创建、销毁的开销
* **非抢占式调度**：协程的调度由程序控制，可通过yield和await方法来暂停和恢复执行
* 异步化编程：让异步代码像些同步代码一样，使得代码结构简洁

**协程和线程有什么区别？**

1）线程由操作系统调度，涉及上下文切换、内核态开销。协程由程序调度，只在用户态切换

2）线程通常是阻塞模型，协程是非阻塞IO

3）线程需要分配栈空间，且栈大小固定，资源消耗大。协程的栈空间可以动态增长，开销小于线程；

## 2.线程池的拒绝策略？

有4种：

* 直接丢弃任务，不抛出异常
* 直接丢弃任务，抛出异常，默认是这个
* 由提交任务的线程来执行
* 丢弃队列中最旧的任务，重新提交任务

## 3.线程池参数怎么配置？有什么坑点？

八股文重点，任务分类型：CPU密集型和I/O密集型

* **CPU密集型**：即单纯的计算任务，不涉及IO操作，不会因为IO而阻塞，因此不需要很多线程，多了反而增加线程切换的开销。通常设置为：**CPU核心数 + 1**

* **I/O密集型**：有很多IO操作，如文件读取、数据库读取等。任务在执行IO操作时，是无法利用CPU的，线程阻塞等待IO完成。因此需要更多线程，提高等待IO时CPU的利用率。核心线程数通常设置为：**CPU核心数 * 2**，最大线程数可以设置更大

***以上公式只是理论值，实际生产中需要考虑限定的CPU利用率等因素，在测试调整得到合理参数***

### 其他坑点

以下内容参考美团技术：https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html

**需要快速响应的场景**：

* 要求瞬时完成，这个时候不应该设置队列去缓冲任务，应该调高corePoolSize和maxPoolSize来创建更多线程快速执行任务

**快速处理批量任务的场景**：

* 如离线大量计算任务，需快速执行。这类任务不要求瞬时完成，所以应该用有限的资源去处理更多任务。需要设置队列去缓冲并发任务，调整corePoolSize来处理任务，需要根据实际情况调整，比如设置数量过多，线程上下文切换开销更大！

**最大线程数设置过小的问题？**

接口并发量增长，大量任务触发拒绝策略抛出异常的问题。队列设置过长问题，导致大量任务堆积到队列中，任务执行时间变长，导致下游服务调用超时！

## 4.线程池参数动态化？

线程池参数的配置很难有一个通用的公式能算出合适的参数，考虑将线程池的参数放到分布式配置中心上，根据实际情况调整后实时生效。

实现原理：

* JDK允许线程池通过ThreadPoolExecutor的实例来动态设置线程池核心参数，包括：setCorePoolSize方法等，设置后，线程池覆盖原来的旧值。并且会比较设置后的corePoolSize 和 当前工作线程数，corePoolSize更大时，且队列中有任务，创建新的Worker线程；corePoolSize更小时，中断Worker线程

## 5. Java8的新特性

回答6点就行：

1）元空间替代永久代

2）引入了Lambda表达式

3）引入了日期类（LocalDate等）、接口默认方法、静态方法（接口中定义方法的默认实现，不需要再实现。静态方法为了将方法内聚在接口中，不用建新对象）

4）新增了Stream流式接口（高效处理数据集合，支持链式操作、并行处理）

5）引入Optional类（优雅的方法处理可能的空指针问题）

6）新增了CompletableFuture等并发类（**异步编程模型**，简化异步任务编写和管理）

## 6.Lambda表达式底层是怎么实现的？

具体原理是：**基于JVM指令invokedynamic**和**函数式接口的动态绑定机制**

Lambda表达式不直接生成匿名内部类，具体为：

* **编译时**，将表达式转换为一个静态方法，方法体就是Lambda的代码逻辑
* **运行时**，通过invokedynamic指令动态绑定到目标函数式接口的实现，避免重复生成类文件

## 7. JDK7中HashMap链表有环的问题说下？

