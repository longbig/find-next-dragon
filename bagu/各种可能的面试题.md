# 各种可能的面试题

## 1.Java

### **（1）Java代码题判断输出对不对(Integer(127)\==Integer(127),Integer(327)==Integer(327))**

在 Java 中，`Integer` 类对值在 `-128` 到 `127` 之间的整数对象进行了缓存，这意味着对于这个范围内的 `Integer`，不管是通过 `Integer.valueOf()` 还是自动装箱（auto-boxing），它们都会返回相同的对象引用。

- 对于值在 `-128` 到 `127` 之间的整数，`Integer.valueOf()` 会从缓存中返回相同的对象，因而通过 `==` 比较它们时，结果为 `true`。
- 对于超出这个范围的整数，`Integer.valueOf()` 会创建新的 `Integer` 对象，因此它们的引用不同，`==` 比较会返回 `false`。

### （2）HashMap 初始容量大小是 16， 扩容加载因子 0.75。 如果容量到 12，肯定会扩容吗？

因此，HashMap 在容量达到 12 时，不会立即扩容，只有当插入第 13 个元素时，它才会触发扩容机制，以将容量翻倍变成 32。因此答案是否定的，容量达到 12 时，并不会立刻进行扩容。扩容会在添加第 13 个键值对时发生。



## 5.JVM中的基础类型和String都存储在什么位置？

**基础类型**：

- 基础数据类型（如 `int`, `char`, `boolean`, 等）在**方法栈帧的局部变量表**中存储。这些变量使用的空间在其方法调用时分配，在方法执行完成后回收。
- 这些类型是直接存储其值的，因为它们所需空间是固定并且是已知的。

**String**：

- `String` 是一个引用类型，**引用变量本身在栈中，但其实际的字符串内容存储在堆内存的对象中**。
- 字符串池：Java 实现了一种**常量池（或字符串池**）的机制，对于字面值创建的字符串，JVM 会将这些字符串保存在字符串池中。这意味着相同的字符串字面值只会有一个实例，优化了内存使用。
- 当程序创建一个新的 `String` 对象时，如果字符串池中已经存在相同内容的字符串，JVM 会重用现有对象存储地址，而不是创建新的对象。



## 6.单例模式的两种实现？

### 饿汉式

* **在类加载时就创建单例实例**。实例通过一个静态变量保存，并在类的静态初始化块中完成初始化。

```java
public class SingletonEager {
     private static final SingletonEager instance = new SingletonEager();

     private SingletonEager() {
         // 构造函数设为私有，防止外部实例化
     }

     public static SingletonEager getInstance() {
         return instance;
     }
}
```

### 懒汉式

* **仅当需要时才创建单例实例**。这种方式通常需要对 `getInstance` 方法进行同步，以解决多线程环境下的安全问题。
* 双重检查锁定的写法：

```java
public class SingletonLazySafe {
    private volatile static SingletonLazySafe instance;

    private SingletonLazySafe() {
        // 构造函数设为私有，防止外部实例化
    }

    public static SingletonLazySafe getInstance() {
        if (instance == null) {
            synchronized (SingletonLazySafe.class) {
                if (instance == null) {
                    instance = new SingletonLazySafe();
                }
            }
        }
        return instance;
    }
}
```

**问题3：饿汉式和懒汉式单例有何不同？什么时候选择使用哪种？**

- 饿汉式在类加载时创建实例，适合于开销小且总是需要使用的情况。
- 懒汉式在需要时创建实例，适合于开销大且不确定是否会用到的情况。



## 7.为什么要用设计模式？设计模式的好处？

* **提高代码的可维护性**，标准化代码结构，使得代码更加清晰、简洁

* **促进代码复用**，避免了重复造轮子，节省了时间和开发成本。

* **增强代码的可扩展性**，提供了解耦的方法，这使得新的功能可以在不破坏现有代码的情况下添加，从而提高系统的可扩展性。

* **解决复杂性问题**，系统逐渐变得复杂时，设计模式提供了一些经过实践验证的解决方案，帮助开发者有效地应对复杂性问题，保持代码的清晰度和可管理性。

- **减少技术债**，减少重复代码的写入和系统扩展时可能出现的复杂问题，降低了系统积累技术债务的风险



## 8.职业规划的回答

### 1. 反思现状

首先，可以简要描述你目前的现状和你所面临的挑战。这段经历能够为你的职业规划提供背景。

示例： “我目前在武汉的国企工作，工作内容相对单调，工资水平也未能与我的技能和市场水平相匹配。在经历了四年的工作后，我感到技术能力有所下降，缺乏成长和挑战。”

### 2. 明确短期目标

然后，说明你对短期目标的规划，即你希望在新的工作中实现什么，尤其是想要在北京的互联网公司做什么样的工作。

示例： “我的短期目标是寻找一个能够提升技术能力和职业成长的机会，特别是想在互联网行业中发挥我的专业技能。我希望加入一个重视创新和高效的团队，参与实际挑战性的项目，从而提升自己的技术深度和广度。”

### 3. 描述长期愿景

接下来，分享你的长期职业愿景，包括想要达成的目标和如何计划实现这些目标。

示例： “从长期来看，我希望能在互联网行业内稳步成长，逐步向架构师或技术管理的方向发展。我希望通过不断积累的项目经验、技术深造及团队合作，能够领导更多的技术项目，最终促进团队和公司的发展。”

### 4. 强调对职位的兴趣

最后，提到你对当前面试职位的兴趣，以及你认为这个职位如何帮助你实现职业规划。

示例： “我对这次申请的职位充满热情，因为我相信这里的工作内容能够让我面临更多复杂的挑战，并与优秀的团队合作，提升我的技术能力。我期待能在这样的环境中不断学习和成长，实现我的职业目标。”

### 综合总结

整个回答中，展示了你的自我反省、目标明确性和对新工作的期待。此外，保持积极的态度是非常重要的，强调你希望通过新机会来实现个人和职业的成长，这样会给面试官留下良好的印象。



## 10.Java多线程问题

### 10.1 多线程打印输出

```java
public class AlternatePrint {
    private static final Object lock = new Object();
    private static boolean turnA = true; // 轮到 A 线程打印

    public static void main(String[] args) {
        Thread threadA = new Thread(() -> {
            for (int i = 0; i < 10; i++) { // 打印 10 次
                synchronized (lock) {
                    while (!turnA) { // 如果不是 A 的轮次，等待
                        try {
                            lock.wait();
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                        }
                    }
                    System.out.print("A"); // 打印 A
                    turnA = false; // 修改轮次
                    lock.notifyAll(); // 唤醒其他线程
                }
            }
        });

        Thread threadB = new Thread(() -> {
            for (int i = 0; i < 10; i++) { // 打印 10 次
                synchronized (lock) {
                    while (turnA) { // 如果是 A 的轮次，等待
                        try {
                            lock.wait();
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                        }
                    }
                    System.out.print("B"); // 打印 B
                    turnA = true; // 修改轮次
                    lock.notifyAll(); // 唤醒其他线程
                }
            }
        });

        threadA.start();
        threadB.start();
    }
}

```

### 10.2 线程池是什么设计模式？生产者和消费者是如何解耦的？

线程池是**生产者-消费者模式**的典型体现，通过任务队列实现生产者和消费者的解耦。以下是具体实现和原理分析：

**1. 角色定义**

- **生产者**：提交任务到线程池的线程（如调用execute()或submit()方法的线程）。 
- **消费者**：线程池中的工作线程（Worker Thread），负责从队列中拉取并执行任务。
- **共享缓冲区**：任务队列（如BlockingQueue），作为生产者和消费者的中间媒介。

**2. 解耦实现**

- **生产者仅关注提交任务**：无需关心任务如何被执行，直接投递到任务队列。
- **消费者仅关注处理任务**：工作线程通过getTask()方法循环从队列中拉取任务，无需感知任务来源。

 **3、解耦的关键设计**

**阻塞队列的作用**

- **线程安全**：通过BlockingQueue的锁机制（如ReentrantLock）保证多线程并发操作的安全性。
- **流量控制**：
  - 队列未满时，生产者直接投递任务，消费者异步处理。
  - 队列已满时，生产者阻塞（或触发拒绝策略），避免系统过载。





## 11.MySQL可能的问题

### 11.1 SQL执行计划的Explain有哪些参数

下面是一个SQL语句的explain参数：

```sql
EXPLAIN
	SELECT * FROM t_dpi_host_baseline a WHERE a.id > (SELECT id FROM t_dpi_host_baseline b WHERE b.id > 1000 limit 1) limit 10;
```

| id   | select_type | table | partitions | type  | possible_keys | key     | key_len | ref    | rows | filtered | Extra                    |
| ---- | ----------- | ----- | ---------- | ----- | ------------- | ------- | ------- | ------ | ---- | -------- | ------------------------ |
| 1    | PRIMARY     | a     | (Null)     | range | PRIMARY       | PRIMARY | 8       | (Null) | 417  | 100.00   | Using where              |
| 2    | SUBQUERY    | b     | (Null)     | range | PRIMARY       | PRIMARY | 8       | (Null) | 417  | 100.00   | Using where; Using index |

1. **id**
   - 查询的序号，标识执行顺序。id相同则按顺序执行，id不同时，数值大的先执行（如子查询）。
2. **select_type**
   - 查询类型：
     - SIMPLE（简单查询，无子查询或UNION）
     - PRIMARY（外层主查询）
     - SUBQUERY（子查询）
     - DERIVED（派生表，如FROM子句中的子查询）
     - UNION（UNION中的第二个SQL语句或后续查询）。
3. **table**
   - 当前操作涉及的表名，可能是别名或派生表名（如<derivedN>）。
4. **type**
   - **访问类型**（**性能关键指标，从优到劣排序**）：
     - system/const：通过主键或唯一索引查询单条记录，索引一次就能找到（注意system是const的特例，表只有一行记录时出现）
     - eq_ref：唯一性索引扫描，表中只有1条记录匹配。通常是两表关联时的字段，是主键/唯一索引
     - ref：非唯一索引的等值查询，返回匹配某个单独值的所有行
     - range：索引范围扫描，检索给定范围的行（如BETWEEN、IN、>）。
     - index：全索引扫描（遍历索引树），all和index都是读全表，但是index是从索引中检索，all是从硬盘中检索
     - ALL：全表扫描（需优化，通常缺失索引）。
5. **possible_keys**
   - 可能使用的索引，若为空，说明需要检查WHERE条件或表结构设计。
6. **key**
   - 实际使用的索引。若为NULL，表示未使用索引（需优化）。
7. **key_len**
   - 使用的索引长度（字节数）。联合索引时可判断是否充分利用所有字段。
8. **ref**
   - 显示索引的哪一列被使用，可能为常量（const）或关联表的字段。
9. **rows**
   - 预估需要扫描的行数。数值越大，性能开销越高。
10. **filter**
    * 表示选取的行和读取的行的百分比，100表示读取了100%，80表示读取了80%

11. **Extra**

- 额外信息，常见值及优化方向：
  - **Using index：覆盖索引，无需回表。**
  - **Using where**：需在存储引擎层后过滤数据（检查索引是否有效），使用了where过滤
  - Using temporary：使用临时表保存中间结果（如GROUP BY无索引）。
  - Using filesort：使用了外部索引排序（考虑优化ORDER BY字段的索引）。
  - Using index condition：5.6之后新增的，表示查询的列有非索引的列，先判断索引的条件，以减少磁盘的IO；
  - Using join buffer：使用了连接缓存；
  - impossible where：where子句的值总是false；

### 11.2 一条SQL语句的执行过程

* 连接器：建立连接，管理连接、校验用户身份；

* 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；

* 解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取**表名、字段、语句类型**；

* 执行 SQL：执行 SQL 共有三个阶段：
  * 预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。
  * 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；
  * 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；





### 11.3 什么场景下数据库不按照你的索引走？索引失效的情况

* 查询条件包含or

* 查询条件里的数据类型和索引字段的类型不匹配，导致隐式类型转换，从而使索引失效，比如：查询时条件里字段类型是字符串，索引的字段类型是整型

* like查询时，通配符% 开头的情况

* 联合索引查询时，条件列不是联合索引的第一个列

* 对索引列进行函数运算如sum（），或是进行列运算，如：+ - * /

* 索引列使用了 !=  < > 条件时，

* 索引列使用了 is null 或者 is not null条件时

* 数据量比较小时，全表扫描比使用索引效率高，优化器可能选择不用索引

  

**查询中的条件未命中索引前缀**：

- 如果索引是复合索引，但查询条件未从索引的最左侧字段开始，可能导致索引未被使用。例如，如果索引是 `(A, B, C)`，但查询仅在 `B` 和 `C` 上有条件，索引可能不会被使用。

**查询条件的模糊匹配**：

- 在 `LIKE` 查询中，如果模式以通配符开头（如 `%abc`），则无法利用索引，因为数据库需要扫描所有行来找到匹配的值。

**数据类型不匹配**：

- 当查询条件的数据类型与索引字段的数据类型不匹配，可能会导致隐式类型转换，从而导致索引失效。例如，将字符串与数字字段比较。

**使用了函数或操作符**：

- 对索引列进行函数运算或复杂表达式（如 `UPPER(column_name)`），会使索引失效，因为索引无法直接应用于运算结果。

**范围查询的后续列**：

- 在使用复合索引时，范围查询 (`>`, `<`, `BETWEEN`, `IN`) 可能会导致索引只在范围前的列上使用，不会在范围后的列上使用。

**统计信息不准确**：

- 数据库的查询优化器依赖于统计信息来选择最优的执行计划。如果统计信息不准确或过时，优化器可能选择不使用索引。

**小表的全表扫描更高效**：

- 当表的数据量较小，甚至全表扫描可能比使用索引更快，优化器可能会选择不使用索引。

**过多随机 I/O**：

- 在某些情况下，如果利用索引会导致大量的随机 I/O，优化器可能会选择全表扫描以进行顺序 I/O。

**聚簇索引和覆盖索引**：

- 当查询列都在覆盖索引中时，会利用这些列进行优化，但如果不符合这样的条件，索引可能会被绕过。





### 11.4 哪些场景不适合建立索引？

* 数据量小的表
* 更新比较频繁的表
* 区分度低的字段不适合加索引，如：性别
* 已经有联合索引的情况，如有联合索引a b，就不需要单独建索引a



### 11.5 什么是覆盖索引？

* 就是SELECT需要的数据列都可以从索引中获取，不需要回表，如有索引列idx_age， 查询语句为：select id,age







## 12.Spring相关问题

### 12.1 AOP的原理了解吗

spring AOP的实现依赖于动态代理技术，指在运行时动态生成代理对象，而不是编译时。

AOP支持两种动态代理：

* **JDK的动态代理**：使用java的Proxy类和InvocationHandler接口实现，这种方式需要代理的类实现一个或多个接口
* **基于CGLIB的动态代理**：当被代理的类没有实现接口，spring使用cglib库生成一个被代理类的子类作为代理，CGLIB（Code Generation Library）是一个第三方代码生成库，通过集成实现代理。





## 13. 如何快速适应其他业务

以电商行业为例：过**业务认知-技术补强-开发实践**的三层递进，重点突破交易、库存、营销等核心领域的技术实现，同时建立可观测、可扩展的架构思维。建议前两周集中研究现有系统文档，通过走查订单生成链路代码理解业务实现细节，快速形成电商领域技术解决方案的能力。

**如果转向电商开发，我会通过三步快速适应：第一，优先理解电商核心业务闭环（如交易、库存、营销），梳理订单生成、支付结算、物流履约等关键链路的技术实现逻辑；第二，针对高并发、分布式事务等电商技术痛点，结合现有系统文档快速补强技术栈，例如通过压力测试验证库存预扣减方案的可靠性，研究分库分表与缓存穿透解决方案；第三，注重业务与技术的结合，例如用策略模式实现优惠券核销规则，通过领域驱动设计划分商品、订单等聚合根，同时搭建监控体系保障系统稳定性。此外，我会主动参与现有模块的代码走查，参考电商开源项目（如订单状态机设计），两周内形成对核心流程的技术实现认知。**
