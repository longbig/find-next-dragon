# 分布式系统学习9：分布式锁

> 这是小卷对分布式系统架构学习的第12篇文章，今天学习面试中高频问题：分布式锁，为什么要做分布式锁，有哪些实现方式，各适用于什么场景等等问题

## 1. 为什么要用分布式锁？

分布式系统下，不同的服务/客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。于是，**分布式锁** 就诞生了

分布式锁的特点：

* **互斥**：任意时刻，锁只能被一个线程持有
* **高可用**：锁服务本身是高可用的，一个节点出问题，能自动切换到另一个节点
* **可重入**：获取过锁的节点，可再次获取锁；
* **超时机制**：为了防止锁无法被释放的异常情况，需要设置超时时间，过了超时时间，锁自动释放；
* **自动续期**：如果任务处理时间超过超时时间，会出现任务未处理完成而锁释放的情况。因此可开启一个监听线程，监听任务还未完成就延长锁的超时时间；

## 2. 乐观锁和悲观锁

* 悲观锁：认为多线程环境下，每次访问共享资源一定会出现冲突，所以**访问资源前就加锁**；
* 乐观锁：认为冲突是偶然情况，没有竞争才是普遍情况。一开始就不加锁，在出现冲突时采取补救措施，简单概述：**先修改共享资源，再验证有没有发生冲突，如没有，则操作完成。如果有其他线程已经修改过这个资源，就放弃本次操作**。

使用场景：

* 乐观锁去除了加锁解锁的操作，但是一旦冲突后的重试成本非常高，只有再冲突概率非常低，且加锁成本比较高的场景，才考虑使用乐观锁

## 3.分布式锁的实现方式

常见分布式锁实现方案如下：

- 基于关系型数据库比如 MySQL 实现分布式锁。
- 基于分布式协调服务 ZooKeeper 实现分布式锁。
- 基于分布式键值存储系统比如 Redis 、Etcd 实现分布式锁。

### 3.1基于Redis的实现

#### setnx + expire组合命令

在redis中，`SETNX`命令可以实现互斥，即Set if not exist的意思，如果key不存在，才可设置key的值，如果key已存在，`SETNX`命令啥也做不了

setnx命令不能设置key的超时时间，因此需要通过expire命令来设置key的超时时间

**加锁**

```shell
> SETNX lockKey uniqueValue
(integer) 1
> SETNX lockKey uniqueValue
(integer) 0
# 设置过期时间
> expire lockKey seconds
```

这里常见的问题就是加锁和设置过期时间是两个操作，不是原子操作，可能出现加锁成功，设置超时时间失败，出现锁永远不会释放的问题。为了解决这个问题，Redis从2.6之后支持setex命令



**释放锁**

释放锁时通过`DEL`命令删除key即可，但不能乱删，要保证执行操作的客户端就是加锁的客户端。为了防止误删了其他锁，这里建议使用lua脚本通过key对应的value来判断，使用Lua脚本保证解锁操作的原子性

```bash
// 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

![](D:\IdeaProjects\find-next-dragon\bagu\img\分布式锁1.png)